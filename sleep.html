<!doctype html>
<html lang="en">
<head>
<title>Dat Data</title>
<meta charset="utf-8">

<link rel="stylesheet" href="/bundle.css">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="/style.css">
</head>
<body>
<div id="choo-root" class="minidocs">
    <div class="_2bbb10f8 minidocs-sidebar">
    <div class="minidocs-header">
      <h1><a href="/"><img src="/dat-data-logo.svg" alt="Dat Data" class="minidocs-logo" /></a></h1>
    </div>
    <div class="_606ae572 minidocs-contents">
    <button class="minidocs-menu-toggle">Menu</button>
    <div class="minidocs-menu menu-closed menu-small">
      <div class="minidocs-menu-wrapper">
        <div class="h1">Dat</div><div><a href="/dat" class="content-link ">Introduction</a></div><div><a href="/how-dat-works" class="content-link ">How Dat Works</a></div><div><a href="/faq" class="content-link ">FAQ</a></div><div class="h1">Cookbook</div><div><a href="/browser" class="content-link ">Browser Dat</a></div><div><a href="/diy-dat" class="content-link ">DIY Dat</a></div><div class="h1">Ecosystem</div><div><a href="/ecosystem" class="content-link ">Overview</a></div><div><a href="/sleep" class="content-link active">SLEEP</a></div><div><a href="/hyperdrive" class="content-link ">Hyperdrive</a></div><div><a href="/hypercore" class="content-link ">Hypercore</a></div>
      </div>
    </div>
  </div>
  </div>
    <div class="_571b6797 minidocs-main">
      <div class="markdown-body">
        <div class="_3f4b1fbc minidocs-content">
    
    
    <div><h1 id="sleep-data-format">SLEEP Data Format</h1>
<h3 id="syncable-lightweight-event-emitting-persistence">Syncable Lightweight Event Emitting Persistence</h3>
<h3 id="version-2-0">Version 2.0</h3>
<p>SLEEP is a metadata format that allows a set of files to be accessed randomly, cryptographically verified, and dynamically updated. A SLEEP file contains content addressed file metadata in a representation specifically designed to allow partial streaming access to individual chunks of data. SLEEP files can be shared as a single downloadable file for easy distribution and we also specify a way to expose SLEEP over REST.</p>
<p>The SLEEP format can be used in a similar way to how MD5 checksums are used over HTTP today, to verify the integrity of data downloads. Whereas MD5 or SHA are usually checksums of the whole data set, meaning consumers have to download the entire all available data before they are able to verify the integrity of any of it, SLEEP allows a set of data to be split in to many small pieces, each one getting it&#39;s own cryptographically secure checksum. This allows consumers to download subsets metadata and data, in whatever order they prefer, but allowing them to verify the integrity of each piece of data as it is accessed. It also includes cryptographic signatures allowing users to verify that data they received was created using a holder of a specific private key.</p>
<h2 id="registers">Registers</h2>
<p>SLEEP is designed around the concept of a register, an append only list that you can trust. The contents of a register are cryptographically fingerprinted and an aggregate checksum can be used to verify the contents of the register have not been tampered with. There are various ways to calculate these aggregate checksums but the data in a register is a binary append only feed, e.g. an list of buffers that can only be updated by placing new buffers at the end of the list.</p>
<p>SLEEP also provides an index that allows each piece of data in a register to be accessed randomly. In order to look up a specific piece of data in the register, you only need a small subset of the metadata in order to find it, making SLEEP suitable for live streaming or sparse download use cases.</p>
<p>The register index is a Merkle tree where the leaf nodes are the hashes of the buffers in the register, and the rest of the nodes in the tree are derived Merkle hashes. A Merkle tree is defined as a tree where leaf nodes are a hash of some piece of data, and the rest of the nodes are the result of a hash of the concatenation of that nodes children.</p>
<p>So, given a register with four values:</p>
<pre><code><span class="hljs-bullet">1. </span>a
<span class="hljs-bullet">2. </span>b
<span class="hljs-bullet">3. </span>c
<span class="hljs-bullet">4. </span>d
</code></pre><p>To construct the register itself you concatenate all buffers, in this case resulting in &#39;abcd&#39;.</p>
<p>The register index is constructed by creating a Merkle tree where the leaf nodes are the hash of our four values, and the rest of the nodes are the hash of the nodes two children hashes concatenated together.</p>
<pre><code>hash(<span class="hljs-name">a</span>)
      &gt; hash(<span class="hljs-name">hash</span>(<span class="hljs-name">a</span>) + hash(<span class="hljs-name">b</span>))
hash(<span class="hljs-name">b</span>)
              &gt; hash(<span class="hljs-name">hash</span>(<span class="hljs-name">hash</span>(<span class="hljs-name">a</span>) + hash(<span class="hljs-name">b</span>)) + hash(<span class="hljs-name">hash</span>(<span class="hljs-name">c</span>) + hash(<span class="hljs-name">d</span>)))
hash(<span class="hljs-name">c</span>)
      &gt; hash(<span class="hljs-name">hash</span>(<span class="hljs-name">c</span>) + hash(<span class="hljs-name">d</span>))
hash(<span class="hljs-name">d</span>)
</code></pre><p>To be able to refer to a specific node in the tree we use an in-order node traversal to assign integers to the nodes:</p>
<pre><code><span class="hljs-number">0</span>
  <span class="hljs-number">1</span>
<span class="hljs-number">2</span>
    <span class="hljs-number">3</span>
<span class="hljs-number">4</span>
  <span class="hljs-number">5</span>
<span class="hljs-number">6</span>
</code></pre><p>In-order node numbering has the property with our trees that leaf nodes are always even and non-leaf nodes are always odd. This can be used as a quick way to identify whether a node is a leaf or not.</p>
<p>Every serialized node in the tree is one of two fixed widths, leaf nodes are all the same size and non-leaf nodes are the same size. When serializing the tree you simply write the nodes in order and concatenate them. Then to access a node by its in-order position you simply multiply the node length by the position to get the byte offset.</p>
<p>All leaf nodes contain these two pieces of information:</p>
<ul>
<li>The sha256 hash of the data described by this node</li>
<li>The absolute byte offset to the end of the region of data described by the node</li>
</ul>
<p>All non-leaf nodes contain these three pieces of information:</p>
<ul>
<li>The sha256 hash of the concatenation of the two children hashes</li>
<li>The cryptographic signature of the hash</li>
<li>The span of bytes that the the nodes children cover</li>
</ul>
<p>When initializing a register an asymmetric Ed25519 keypair is derived. The private key is never shared. The public key is used as the URL for the register. When signing hashes in the tree the public key is used to generate an EdDSA signature. For the example register above, &#39;abcd&#39;, the register index (in JSON) would be:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> keys = {
  <span class="hljs-attr">public</span>: <span class="hljs-string">'cc0cf6eeb82ca946ca60265ce0863fb2b3e3075ae25cba14d162ef20e3f9f223'</span>,
  <span class="hljs-attr">private</span>: <span class="hljs-string">'87399f90815db81e687efe4fd9fc60af336f4d9ae560fda106f94cb7a92a8804cc0cf6eeb82ca946ca60265ce0863fb2b3e3075ae25cba14d162ef20e3f9f223'</span>
}

<span class="hljs-keyword">var</span> index = {
  <span class="hljs-comment">// sha256 of children[0].hash + children[1].hash</span>
  hash: <span class="hljs-string">'0440c655d63fec5c02cffd5d9b42d146aca03b255102b9b44b51c6a919b31351'</span>,
  <span class="hljs-attr">signature</span>: <span class="hljs-string">'1713dfbaf4a7f288003394b72ec486aa4fa1a837aa0b08662b3a14b63381b84c2e6965e2638fb5375ae2e92b47c2ab8718ec1914778518fcb3c0563eb2c09604'</span>,
  <span class="hljs-attr">span</span>: <span class="hljs-number">4</span>,
  <span class="hljs-attr">children</span>: [
    {
      <span class="hljs-comment">// echo -n "$(echo -n "a" | shasum -a 256)$(echo -n "b" | shasum -a 256)" | shasum -a 256</span>
      hash: <span class="hljs-string">'9ad4d5608a7a40db60c35f255fad821b762a82de168b4f4ed477d5d899b11796'</span>,
      <span class="hljs-attr">signature</span>: <span class="hljs-string">'2714b99e305ce46aa6d24eb2888cf0cbde33ad4a8bcd08705b59882837bf1e482f8dcab2ae94c2359914b1fe92831bfc73af99f1c6b1f5eba47efc4efa32de0d'</span>,
      <span class="hljs-attr">span</span>: <span class="hljs-number">2</span>,
      <span class="hljs-attr">children</span>: [
        {
          <span class="hljs-comment">// echo -n "a" | shasum -a 256</span>
          hash: <span class="hljs-string">'ca978112ca1bbdcafac231b39a23dc4da786eff8147c4e72b9807785afee48bb'</span>,
          <span class="hljs-attr">endByte</span>: <span class="hljs-number">1</span>
        },
        {
          <span class="hljs-comment">// echo -n "b" | shasum -a 256</span>
          hash: <span class="hljs-string">'3e23e8160039594a33894f6564e1b1348bbd7a0088d42c4acb73eeaed59c009d'</span>,
          <span class="hljs-attr">endByte</span>: <span class="hljs-number">2</span>
        }
      ]
    },
    {
      <span class="hljs-comment">// echo -n "$(echo -n "c" | shasum -a 256)$(echo -n "d" | shasum -a 256)" | shasum -a 256</span>
      hash: <span class="hljs-string">'09114d1a8a78b5d091e492c524ad7f8e941f403db0a6d3d52d36f17b9a86ce1c'</span>,
      <span class="hljs-attr">signature</span>: <span class="hljs-string">'6ac5e25206f69f22612e9b58c14f9ae6738233a57ab7f6e10c1384c4e074f6c8c606edbd95a9c099a0120947866079e3d13ef66dd7d5ed1756a89a5e9032a20d'</span>,
      <span class="hljs-attr">span</span>: <span class="hljs-number">2</span>,
      <span class="hljs-attr">children</span>: [
        {
          <span class="hljs-comment">// echo -n "c" | shasum -a 256</span>
          hash: <span class="hljs-string">'2e7d2c03a9507ae265ecf5b5356885a53393a2029d241394997265a1a25aefc6'</span>,
          <span class="hljs-attr">endByte</span>: <span class="hljs-number">3</span>
        },
        {
          <span class="hljs-comment">// echo -n "d" | shasum -a 256</span>
          hash: <span class="hljs-string">'18ac3e7343f016890c510e93f935261169d9e3f565436429830faf0934f4f8e4'</span>,
          <span class="hljs-attr">endByte</span>: <span class="hljs-number">4</span>
        }
      ]
    }
  ]
}
</code></pre>
<p>The above representation of the tree is in JSON. However due to the properties of the in-order node indexes we can represent the same data in a flat index while still allowing traversals.</p>
<h1 id="file-format">File format</h1>
<p>SLEEP files should be named <code>sleep.dat</code> and have the following format:</p>
<pre><code>&lt;<span class="hljs-keyword">Header</span>&gt;&lt;Register Index<span class="hljs-params">...</span>&gt;&lt;Register <span class="hljs-built_in">Data</span><span class="hljs-params">...</span>&gt;
</code></pre><p>The format is a header followed by the register index. Order of the index is determined by an in-order node traversal. After the register index, the actual register entry data follows. The header length is variable width, prefixed with a varint. The Register Index is composed of fixed width metadata entries. The Register Data is composed of concatenated non-fixed width data pieces.</p>
<h3 id="header-format">Header format</h3>
<pre><code><span class="hljs-section">&lt;varint header-length&gt;</span><span class="hljs-section">&lt;header protobuf&gt;</span>
</code></pre><p>The header protobuf has this schema:</p>
<pre><code class="lang-protobuf"><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">Header</span> </span>{
  <span class="hljs-keyword">required</span> <span class="hljs-built_in">bytes</span> datLink = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">required</span> <span class="hljs-built_in">uint64</span> entryCount = <span class="hljs-number">2</span>;
  <span class="hljs-keyword">optional</span> <span class="hljs-built_in">bool</span> isSigned = <span class="hljs-number">3</span>;
  <span class="hljs-keyword">optional</span> <span class="hljs-built_in">string</span> hashType = <span class="hljs-number">4</span> [default = <span class="hljs-string">"sha256"</span>];
  <span class="hljs-keyword">optional</span> <span class="hljs-built_in">uint32</span> hashLength = <span class="hljs-number">5</span> [default = <span class="hljs-number">32</span>];
  <span class="hljs-keyword">optional</span> <span class="hljs-built_in">string</span> signatureType = <span class="hljs-number">6</span> [default = <span class="hljs-string">"ed25519"</span>];
  <span class="hljs-keyword">optional</span> <span class="hljs-built_in">uint32</span> signatureLength = <span class="hljs-number">7</span> [default = <span class="hljs-number">64</span>];
}
</code></pre>
<h3 id="register-index-format">Register Index format</h3>
<p>For non-signed even (leaf) nodes:</p>
<pre><code><span class="hljs-section">&lt;8-byte-span-length&gt;</span><span class="hljs-section">&lt;data-hash&gt;</span>
</code></pre><p>The 8-byte-span-length is an unsigned big endian 64 bit integer that should be number of cumulative bytes encompassed by all of the leaf nodes underneath the current node.</p>
<p>For signed even (leaf) nodes:</p>
<pre><code><span class="hljs-section">&lt;8-byte-span-length&gt;</span><span class="hljs-section">&lt;data-hash-signature&gt;</span><span class="hljs-section">&lt;data-hash&gt;</span>
</code></pre><p>For odd (non-leaf) nodes:</p>
<pre><code>&lt;<span class="hljs-number">8</span>-<span class="hljs-keyword">byte</span>-<span class="hljs-keyword">end</span>-<span class="hljs-built_in">offset</span>&gt;&lt;data-hash&gt;
</code></pre><p>The 8-byte-end-offset is an unsigned big endian 64 bit integer that should be the absolute position in the file for the <strong>end</strong> of the piece data described by this node.</p>
<h3 id="register-data">Register Data</h3>
<p>The last section of the file is the actual data pieces, unmodified and concatenated together in sequential order.</p>
<p>For the example tree above, the Register Data section would simply be <code>abcd</code>.</p>
<h2 id="example">Example</h2>
<p>Given a tree like this you might want to look up in a <code>meta.dat</code> file the metadata for a specific node:</p>
<pre><code><span class="hljs-number">0</span>─┐  
  <span class="hljs-number">1</span>─┐
<span class="hljs-number">2</span>─┘ │
    <span class="hljs-number">3</span>
<span class="hljs-number">4</span>─┐ │
  <span class="hljs-number">5</span>─┘
<span class="hljs-number">6</span>─┘
</code></pre><p>If you wanted to look up the metadata for 3, you could read the third (or any!) entry from sleep.dat:</p>
<p>First you have to read the varint at the beginning of the file so you know how big the header is:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> varint = <span class="hljs-built_in">require</span>(<span class="hljs-string">'varint'</span>) <span class="hljs-comment">// https://github.com/chrisdickinson/varint</span>
<span class="hljs-keyword">var</span> headerLength = varint.decode(firstChunkOfFile)
</code></pre>
<p>Now you can read the header from the file</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> headerOffset = varint.encodingLength(headerLength)
<span class="hljs-keyword">var</span> headerEndOffset = headerOffset + headerLength
<span class="hljs-keyword">var</span> headerBytes = firstChunkOfFile.slice(headerOffset, headerEndOffset)
</code></pre>
<p>To decode the header use the protobuf schema. We can use the <a href="https://github.com/mafintosh/protocol-buffers">protocol-buffers</a> module to do that.</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> messages = <span class="hljs-built_in">require</span>(<span class="hljs-string">'protocol-buffers'</span>)(fs.readFileSync(<span class="hljs-string">'meta.dat.proto'</span>))
<span class="hljs-keyword">var</span> header = messages.Header.decode(headerBytes)
</code></pre>
<p>Now we have all the configuration required to calculate an entry offset.</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> entryNumber = <span class="hljs-number">42</span>
<span class="hljs-keyword">var</span> entryOffset = headerEndOffset + entryNumber * (<span class="hljs-number">8</span> + header.hashLength)
</code></pre>
<p>If you have a signed feed, you have to take into account the extra space required for the signatures in the even nodes.</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> entryOffset = headerLength + entryNumber * (<span class="hljs-number">8</span> + header.hashLength)
                  + <span class="hljs-built_in">Math</span>.floor(entryNumber / <span class="hljs-number">2</span>) * header.signatureLength
</code></pre>
</div>
  </div>
      </div>
    </div>
  </div>
<script src="/bundle.js"></script>
</body>
</html>
